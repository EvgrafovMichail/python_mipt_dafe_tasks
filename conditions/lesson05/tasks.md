# Задача 1: Туда-сюда

**Условие:**  
Строка называется **палиндромом**, если она читается одинаково слева направо и справа налево. При этом **регистр букв игнорируется**: `'A'` и `'a'` считаются одинаковыми символами.  

Ваша задача — определить, является ли заданная строка палиндромом.

Допишите код в файле [task1](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task1.py).

**Входные данные:**  
- `text` — строка, состоящая из букв английского алфавита в верхнем и нижнем регистре длиной от 0 до 1000.

**Выходные данные:**  
- `True`, если строка является палиндромом (с учётом игнорирования регистра), `False` - иначе.

**Примеры:**

| Входные данные | Выходные данные |
|----------------|-----------------|
| `"aba"`        | `True`          |
| `"Aa"`         | `True`          |
| `"hello"`      | `False`         |


# Задача 2: Mr. Mojo Risin
**Условие:**  
Два слова называются **анаграммами**, если одно можно получить из другого перестановкой букв. При этом **регистр букв имеет значение**: символы `'A'` и `'a'` считаются **разными**.  

Ваша задача — определить, являются ли два заданных слова анаграммами. Решение должно работать за **O(N + M)** времени и использовать не более **O(1)** дополнительной памяти (где **N** и **M** — длины слов).

Допишите код в файле [task2](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task2.py).

**Входные данные:**  
- `word1` — непустая строка из букв английского алфавита (верхний и нижний регистр), длиной от 1 до 1000;
- `word2` — непустая строка из букв английского алфавита (верхний и нижний регистр), длиной от 1 до 1000.

**Выходные данные:**  
- `True`, если слова являются анаграммами (с учётом регистра), `False` - иначе.

**Примеры:**

| Входные данные      | Выходные данные |
|---------------------|-----------------|
| `listen`<br>`silent`| `True`          |
| `abc`<br>`aac`      | `False`         |


# Задача 3: ?!
**Условие:**  
Вам дана строка. Требуется определить, состоит ли она **исключительно из знаков пунктуации** (без букв, цифр, пробелов и любых других символов).  

К знакам пунктуации относятся: **!"#$%&\'()*+,-./:;<=>?@[\\]^_{|}~`**

Пустая строка **не считается** строкой из пунктуации.

Допишите код в файле [task3](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task3.py).

**Входные данные:**  
- `text` — строка из букв, цифр, пробелов и знаков препинания, длиной от 0 до 1000 символов.

**Выходные данные:**  
- `True`, если строка **непустая** и **каждый её символ** является знаком пунктуации, `False` — иначе.

**Примеры:**

| Входные данные | Выходные данные |
|----------------|-----------------|
| `"!?."`        | `True`          |
| `"Hello!"`     | `False`         |
| `""`           | `False`         |

# Задача 4: Разархиватор
**Условие:**  
Некоторый архиватор сжимает тексты, состоящие **только из букв** (без пробелов и других символов), следующим образом:  
- Если в тексте встречается подстрока, повторяющаяся **N раз подряд**, она заменяется на запись вида `подстрока*N`.  
- Все такие фрагменты (сжатые и несжатые) записываются в результат через **пробел**.  

Например, строка `'AbcDAbcDAbcDAbcDefGhIGhI'` может быть заархивирована как `'AbcD*4 ef GhI*2'`.

Ваша задача — реализовать **разархиватор**: по заархивированной строке восстановить исходный текст.

Допишите код в файле [task4](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task4.py).

**Входные данные:**  
- `compress_text` — строка, содержащая токены, разделённые пробелами, длиной не более 1000. Каждый токен состоит:
    - либо только из букв (например, `ef`);
    - либо имеет формат `B*N`, где `B` — непустая строка из букв, `N` — целое неотрицательное число (например, `AbcD*4`).

**Выходные данные:**  
- Строка, состоящая **только из букв** — результат разархивации.


**Примеры:**

| Входные данные         | Выходные данные               |
|------------------------|-------------------------------|
| `AbcD*4 ef GhI*2`      | `AbcDAbcDAbcDAbcDefGhIGhI`    |
| `a*3 b*2`              | `aaabb`                       |

# Задача 5: Простые (или нет) регулярные выражения

**Условие:**

В программировании при работе со строками вы повстречаетесь с так называемыми регулярными выражениями. Они много, где используются, но сегодня с помощью них мы будем проверять соответствует ли строка нужному формату. Использовать настоящие регулярные выражения мы не будем, так как они достаточно сложные, поэтому работать мы будем со своим аналогом.
Итак, регулярное выражение – это строка, содержащая следующие символы:

- `d` означает, что в строке в этом месте записано целое число;
- `w` означает, что в строке в этом месте записано слово, состоящее только из букв;
- `s` означает, что в строке в этом месте записана строка, состоящая только из букв или цифр;
- любой символ не буква и не цифра (может быть пробел) - это означает, что в этом месте стоит (один) написаный символ.

В регулярном выражении не могут подряд стоять `dd`, `ww`, `ss`, `sd`, `sw`, `ws`, `ds`.

Мы утверждаем, что строка соответствует регулярному выражению, если порядок символов в строке соответствует порядку символов в регулярном выражении.
То есть, например, если регулярное выражение равно `“d-dw”` – это означает, что в строке должно быть записано целое число, потом `-`, потом опять число, потом строка из букв и если чего-то нет, например, второго числа или наоборот есть лишнее, например после первого числа идет буква, то мы говорим, что строка не соответствует регулярному выражению. Таким образом, строка `"12-45abc"` соответствует регулярному выражению, а строки `"1-abs"`, `"1-b123r"`, `"1--123vdg"` - нет.

*Использование модуля `re` или других инструментов для работы с регулярными выражениями запрещено.*

Допишите код в файле [task5](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task5.py).

**Входные данные:** 
- `reg_expr` - cтрока, состоящая из букв `d`, `w` и `s` и символов (не буквы и не цифры) - регулярное выражение. Длина строки находится в диапазоне от 0 до 10;
- `text` - строка, состоящая из букв английского алфавита верхнего и нижнего регистра, цифр и других символов - строка, которую надо проверить на соответствие регулярному выражению. Длина строки от 0 до 100.

**Выходные данные:**  
- `True` - если строка соответствует регулярному выражению, `False` - иначе.

**Примеры:**

| Входные данные         | Выходные данные |
|------------------------|-----------------|
| `d-dw`<br>`123-456abc` | `True`          |
| `d-dw`<br>`123-456`    | `False`         |
| `s-dw`<br>`123a-456abc`| `True`          |

# Задача 6: У самурая нет цели, есть только путь

**Условие:**

Вы разрабатываете файловое хранилище в Unix-подобной системе. Пользователи вашего хранилища могут получать доступ к файлам и к директориям, указав абсолютный путь до требуемого ресурса. Поисковый движок вашей файловой системы при поиске ресурса в точности повторяет обход файловой системы, описанный пользователем. Поскольку пользователи могут писать неоптимальные запросы на обход файловой системы (путь к ресурсу), перед вами встала задача реализации алгоритма упрощения пути, с целью избежать лишних обходов директорий.

В Unix-подобной файловой системе одиночная точка `.` обозначает текущий каталог, двойная точка '..' обозначает перемещение на один уровень вверх, а несколько косых черт, таких как `//`, интерпретируются как одна косая черта. Последовательности точек, не охваченные предыдущими правилами (например, `...`), рассматриваются как допустимые имена файлов или каталогов.

Упрощенный канонический путь должен соответствовать следующим правилам:

- Он должен начинаться с одной косой черты `/`.
- Каталоги в пути должны быть разделены только одной косой чертой `/`.
- Он не должен заканчиваться косой чертой `/`, если только это не корневой каталог.
- Он должен исключить любые одиночные или двойные точки, используемые для обозначения текущих или родительских каталогов.

Ваша задача реализовать алгоритм для упрощения переданного пути.

Если изначальный путь поднимается выше корневого каталога, например, `/../` или `/a/../../`, то необходимо вернуть пустую строку.

Допишите код в файле [task6](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson05/task6.py).

**Входные данные:** 

- `path` - строка, состоящая из букв английского алфавита в верхнем и нижнем регистре, и символов `.`, `/`, `_`. Длина строки находится в диапазоне от 1 до 1000.

**Выходные данные:**  
- Строка - упрощенный абсолютный канонический путь.

**Примеры:**

| Входные данные                          | Выходные данные               |
|-----------------------------------------|-------------------------------|
| `"/home/"`                              | `"/home"`                     |
| `/home/user/./Documents/../Pictures`    | `"/home/user/Pictures"`       |
| `/home//foo/`                           | `"/home/foo"`                 |
| `/../foo/`                              | `""`                          |
